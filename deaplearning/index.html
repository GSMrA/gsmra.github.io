<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Foot IA 3D - Double Agent RL</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #111; }
        #overlay {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.85); padding: 15px; border-radius: 10px;
            width: 340px; user-select: none; border: 1px solid #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        h2 { margin: 0 0 10px 0; font-size: 18px; color: #4CAF50; border-bottom: 1px solid #444; padding-bottom: 5px; }
        input[type=range] { width: 100%; accent-color: #4CAF50; cursor: pointer; margin: 10px 0; }
        .bar-container { width: 100%; background: #333; height: 10px; border-radius: 5px; margin-top: 5px; overflow: hidden;}
        .bar-fill { height: 100%; transition: width 0.2s; }
        .bar-blue { background: #2196F3; }
        .bar-red { background: #f44336; }
        #logs { 
            font-family: monospace; font-size: 11px; color: #aaa; margin-top: 10px; 
            height: 80px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px;
        }
        .status-led { display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: #555; margin-right: 5px; }
        .training { background: #ffeb3b; box-shadow: 0 0 5px #ffeb3b; }
        .ready { background: #4CAF50; box-shadow: 0 0 5px #4CAF50; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs"
            }
        }
    </script>
</head>
<body>
    <div id="overlay">
        <h2>Double IA Dashboard <span id="statusLed" class="status-led ready"></span></h2>
        
        <div class="stat-row">
            <span>Score (Bleu v Rouge)</span>
            <span id="score" style="font-weight:bold; color:#fff">0 - 0</span>
        </div>

        <div style="margin-top: 10px;">
            <label>Vitesse Simulation: <span id="speedVal">1x</span></label>
            <input type="range" id="speedSlider" min="1" max="50" step="1" value="1">
        </div>

        <div style="margin-top: 10px;">
            <label>Exploration Bleu: <span id="epsilonBlueVal">60%</span></label>
            <div class="bar-container">
                <div id="epsilonBlueBar" class="bar-fill bar-blue" style="width: 60%;"></div>
            </div>
        </div>

        <div style="margin-top: 10px;">
            <label>Exploration Rouge: <span id="epsilonRedVal">60%</span></label>
            <div class="bar-container">
                <div id="epsilonRedBar" class="bar-fill bar-red" style="width: 60%;"></div>
            </div>
        </div>

        <div id="logs">Système prêt. Deux IA en apprentissage.</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';
        import * as tf from '@tensorflow/tfjs';

        // --- LOGGER ---
        function log(msg) {
            const el = document.getElementById('logs');
            const time = new Date().toLocaleTimeString().split(' ')[0];
            el.innerHTML = `<div style="margin-bottom:2px"><span style="color:#666">[${time}]</span> ${msg}</div>` + el.innerHTML;
        }

        // --- SCENE THREE.JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(45, 35, 0); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lumières
        const dl = new THREE.DirectionalLight(0xffffff, 1.5);
        dl.position.set(10, 30, 10);
        dl.castShadow = true;
        dl.shadow.camera.left = -40; dl.shadow.camera.right = 40;
        dl.shadow.camera.top = 40; dl.shadow.camera.bottom = -40;
        scene.add(dl);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        // --- PHYSIQUE ---
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.81, 0) });
        const matGround = new CANNON.Material();
        const matPlayer = new CANNON.Material();
        const matBall = new CANNON.Material();

        world.addContactMaterial(new CANNON.ContactMaterial(matGround, matPlayer, { friction: 0.0, restitution: 0 }));
        world.addContactMaterial(new CANNON.ContactMaterial(matGround, matBall, { friction: 0.3, restitution: 0.7 }));
        world.addContactMaterial(new CANNON.ContactMaterial(matPlayer, matBall, { friction: 0.1, restitution: 0.5 }));

        const syncObjects = [];

        function createMeshBody(geo, mat, mass, pos, cMat, color) {
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: color }));
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);

            let shape;
            if (geo.type === 'BoxGeometry') shape = new CANNON.Box(new CANNON.Vec3(geo.parameters.width/2, geo.parameters.height/2, geo.parameters.depth/2));
            else if (geo.type === 'SphereGeometry') shape = new CANNON.Sphere(geo.parameters.radius);

            const body = new CANNON.Body({ mass: mass, material: cMat });
            body.addShape(shape);
            body.position.copy(pos);
            if (mass > 0 && geo.type !== 'SphereGeometry') body.fixedRotation = true;
            
            world.addBody(body);
            syncObjects.push({ mesh, body });
            return body;
        }

        // Terrain & Murs
        const groundGeo = new THREE.PlaneGeometry(30, 50);
        const groundMesh = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x228b22 }));
        groundMesh.rotation.x = -Math.PI/2; groundMesh.receiveShadow = true;
        scene.add(groundMesh);
        const groundBody = new CANNON.Body({ mass: 0, material: matGround });
        groundBody.addShape(new CANNON.Plane());
        groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
        world.addBody(groundBody);

        function addWall(x, z, w, d) {
            const b = new CANNON.Body({ mass: 0 });
            b.addShape(new CANNON.Box(new CANNON.Vec3(w/2, 2, d/2)));
            b.position.set(x, 2, z);
            world.addBody(b);
        }
        addWall(16, 0, 2, 50); addWall(-16, 0, 2, 50);
        addWall(0, 26, 30, 2); addWall(0, -26, 30, 2);

        // Buts
        function createGoal(z, color) {
            const goalMat = new THREE.MeshStandardMaterial({color: color});
            const p1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), goalMat); p1.position.set(4, 2, z); scene.add(p1);
            const p2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), goalMat); p2.position.set(-4, 2, z); scene.add(p2);
            const p3 = new THREE.Mesh(new THREE.BoxGeometry(8.5, 0.5, 0.5), goalMat); p3.position.set(0, 4, z); scene.add(p3);
        }
        createGoal(-25, 0x0000ff); createGoal(25, 0xff0000);

        // Entités
        const blue = createMeshBody(new THREE.BoxGeometry(2,2,2), null, 5, new THREE.Vector3(0,1,15), matPlayer, 0x0088ff);
        const red = createMeshBody(new THREE.BoxGeometry(2,2,2), null, 5, new THREE.Vector3(0,1,-15), matPlayer, 0xff4444);
        const ball = createMeshBody(new THREE.SphereGeometry(0.8), null, 1, new THREE.Vector3(0,5,0), matBall, 0xffffff);
        ball.angularDamping = 0.5;

        // --- IA TENSORFLOW (DOUBLE AGENTS) ---
        function createModel() {
            const model = tf.sequential();
            model.add(tf.layers.dense({inputShape: [8], units: 32, activation: 'relu'}));
            model.add(tf.layers.dense({units: 32, activation: 'relu'}));
            model.add(tf.layers.dense({units: 16, activation: 'relu'}));
            model.add(tf.layers.dense({units: 2, activation: 'tanh'})); // Force X, Z
            
            model.compile({
                optimizer: tf.train.adam(0.003),
                loss: 'meanSquaredError'
            });
            
            return model;
        }

        const modelBlue = createModel();
        const modelRed = createModel();

        // Variables Apprentissage (départ à 60% au lieu de 100%)
        let epsilonBlue = 0.6;  // Commence à 60% d'exploration
        let epsilonRed = 0.6;
        const EPSILON_MIN = 0.04; // Arrêt à 4%
        const EPSILON_DECAY = 0.99985; // Décroissance plus rapide pour atteindre 4%
        
        let isTrainingBlue = false;
        let isTrainingRed = false;
        let scoreB = 0, scoreR = 0;
        let lastDistBlue = 1000;
        let lastDistRed = 1000;

        async function trainStep(model, state, action, reward, isBlue) {
            const trainingFlag = isBlue ? 'isTrainingBlue' : 'isTrainingRed';
            if (eval(trainingFlag)) return;
            if (reward === 0) return;

            if (isBlue) isTrainingBlue = true;
            else isTrainingRed = true;
            
            document.getElementById('statusLed').className = "status-led training";

            try {
                const stateT = tf.tensor2d([state]);
                const actionT = tf.tensor2d([action]);
                
                // Entraînement avec pondération par reward
                if (reward > 0) {
                    const scaledAction = tf.mul(actionT, reward * 0.5);
                    await model.fit(stateT, scaledAction, { epochs: 1, verbose: 0 });
                    scaledAction.dispose();
                } else if (reward < 0) {
                    // Pénalité: inverser légèrement l'action
                    const invertedAction = tf.mul(actionT, -0.3);
                    await model.fit(stateT, invertedAction, { epochs: 1, verbose: 0 });
                    invertedAction.dispose();
                }
                
                stateT.dispose();
                actionT.dispose();
            } catch (e) {
                console.error(e);
            }

            if (isBlue) isTrainingBlue = false;
            else isTrainingRed = false;
            
            document.getElementById('statusLed').className = "status-led ready";
        }

        // --- GAME LOOP ---
        let simSpeed = 1;
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            simSpeed = parseInt(e.target.value);
            document.getElementById('speedVal').innerText = simSpeed + "x";
        });

        function reset() {
            ball.position.set(0, 5, 0); ball.velocity.set(0,0,0); ball.angularVelocity.set(0,0,0);
            blue.position.set(0, 1, 15); blue.velocity.set(0,0,0);
            red.position.set(0, 1, -15); red.velocity.set(0,0,0);
            lastDistBlue = 1000;
            lastDistRed = 1000;
        }

        function getState(player, goalZ) {
            return [
                player.position.x/30, 
                player.position.z/50,
                ball.position.x/30, 
                ball.position.z/50,
                (ball.position.x - player.position.x)/30,
                (ball.position.z - player.position.z)/50,
                ball.velocity.x/10,
                (goalZ - ball.position.z)/50  // Distance au but visé
            ];
        }

        function update() {
            for(let i=0; i<simSpeed; i++) {
                world.step(1/60);

                // --- IA BLEU ---
                if (i % 3 === 0) {
                    const s = getState(blue, -25);
                    let act = [0,0];
                    
                    if (Math.random() < epsilonBlue) {
                        // Exploration guidée (moins aléatoire)
                        const dirToBall = new THREE.Vector2(
                            ball.position.x - blue.position.x,
                            ball.position.z - blue.position.z
                        ).normalize();
                        const randomness = 0.4;
                        act = [
                            dirToBall.x * (1-randomness) + (Math.random()*2-1) * randomness,
                            dirToBall.y * (1-randomness) + (Math.random()*2-1) * randomness
                        ];
                    } else {
                        const pred = modelBlue.predict(tf.tensor2d([s]));
                        act = Array.from(pred.dataSync());
                        pred.dispose();
                    }

                    blue.applyForce(new CANNON.Vec3(act[0]*70, 0, act[1]*70));

                    // Récompenses
                    const d = blue.position.distanceTo(ball.position);
                    let r = 0;
                    
                    if (d < lastDistBlue) r = 0.15;
                    if (d < 2) r = 1.5;
                    if (d < 1.2) r = 3.0;
                    if (ball.velocity.z < -1 && d < 3) r = 2.5; // Balle vers but adverse
                    
                    if (!isTrainingBlue && r > 0) {
                        trainStep(modelBlue, s, act, r, true);
                    }
                    
                    lastDistBlue = d;
                    if(epsilonBlue > EPSILON_MIN) epsilonBlue *= EPSILON_DECAY;
                }

                // --- IA ROUGE ---
                if (i % 3 === 0) {
                    const s = getState(red, 25);
                    let act = [0,0];
                    
                    if (Math.random() < epsilonRed) {
                        // Exploration guidée
                        const dirToBall = new THREE.Vector2(
                            ball.position.x - red.position.x,
                            ball.position.z - red.position.z
                        ).normalize();
                        const randomness = 0.4;
                        act = [
                            dirToBall.x * (1-randomness) + (Math.random()*2-1) * randomness,
                            dirToBall.y * (1-randomness) + (Math.random()*2-1) * randomness
                        ];
                    } else {
                        const pred = modelRed.predict(tf.tensor2d([s]));
                        act = Array.from(pred.dataSync());
                        pred.dispose();
                    }

                    red.applyForce(new CANNON.Vec3(act[0]*70, 0, act[1]*70));

                    // Récompenses
                    const d = red.position.distanceTo(ball.position);
                    let r = 0;
                    
                    if (d < lastDistRed) r = 0.15;
                    if (d < 2) r = 1.5;
                    if (d < 1.2) r = 3.0;
                    if (ball.velocity.z > 1 && d < 3) r = 2.5; // Balle vers but adverse
                    
                    if (!isTrainingRed && r > 0) {
                        trainStep(modelRed, s, act, r, false);
                    }
                    
                    lastDistRed = d;
                    if(epsilonRed > EPSILON_MIN) epsilonRed *= EPSILON_DECAY;
                }

                // --- BUTS ---
                if (ball.position.z < -25) {
                    scoreB++;
                    log("⚽ <span style='color:#0088ff'>BUT BLEU!</span> (+10 pts)");
                    document.getElementById('score').innerText = `${scoreB} - ${scoreR}`;
                    
                    // Récompense massive pour le bleu
                    const sBlue = getState(blue, -25);
                    const lastAction = [0, -1]; // Approximation
                    trainStep(modelBlue, sBlue, lastAction, 10, true);
                    
                    // Pénalité pour le rouge
                    const sRed = getState(red, 25);
                    const lastActionRed = [0, 1];
                    trainStep(modelRed, sRed, lastActionRed, -3, false);
                    
                    reset();
                }
                if (ball.position.z > 25) {
                    scoreR++;
                    log("⚽ <span style='color:#ff4444'>BUT ROUGE!</span> (+10 pts)");
                    document.getElementById('score').innerText = `${scoreB} - ${scoreR}`;
                    
                    // Récompense massive pour le rouge
                    const sRed = getState(red, 25);
                    const lastAction = [0, 1];
                    trainStep(modelRed, sRed, lastAction, 10, false);
                    
                    // Pénalité pour le bleu
                    const sBlue = getState(blue, -25);
                    const lastActionBlue = [0, -1];
                    trainStep(modelBlue, sBlue, lastActionBlue, -3, true);
                    
                    reset();
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            
            syncObjects.forEach(o => {
                o.mesh.position.copy(o.body.position);
                o.mesh.quaternion.copy(o.body.quaternion);
            });

            // UI
            document.getElementById('epsilonBlueBar').style.width = (epsilonBlue*100) + "%";
            document.getElementById('epsilonBlueVal').innerText = Math.floor(epsilonBlue*100) + "%";
            document.getElementById('epsilonRedBar').style.width = (epsilonRed*100) + "%";
            document.getElementById('epsilonRedVal').innerText = Math.floor(epsilonRed*100) + "%";

            controls.update();
            renderer.render(scene, camera);
        }
        
        log("✓ Deux IA initialisées. Exploration: 60% → 4%");
        animate();
    </script>
</body>
</html>
