<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Foot IA - Apprentissage Instantané</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: monospace; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.8); color: white;
            padding: 15px; border-radius: 8px; width: 300px;
            pointer-events: none; user-select: none;
            border-left: 5px solid #00ff88;
        }
        .row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .score { font-size: 24px; font-weight: bold; text-align: center; margin: 10px 0; }
        .b { color: #4488ff; } .r { color: #ff4444; }
        #logs { font-size: 10px; color: #888; height: 60px; overflow: hidden; margin-top:10px;}
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs"
            }
        }
    </script>
</head>
<body>
    <div id="ui">
        <div class="row"><span>IA STATUS:</span> <span style="color:#0f0">ACTIVE</span></div>
        <div class="score"><span class="b" id="sB">0</span> - <span class="r" id="sR">0</span></div>
        <div class="row"><span>Exploration:</span> <span id="eps">20%</span></div>
        <div class="row"><span>Mémoire:</span> <span id="mem">0</span></div>
        <div id="logs">Initialisation...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';
        import * as tf from '@tensorflow/tfjs';

        // --- CONFIGURATION ---
        const CONFIG = {
            speed: 2,           // Vitesse globale du jeu
            moveForce: 80,      // Puissance de déplacement
            dashForce: 400,     // Puissance du Dash
            batchSize: 32,      // Taille apprentissage
            learningRate: 0.005 // Vitesse d'apprentissage (agressif)
        };

        const ACTIONS = ['UP', 'DOWN', 'LEFT', 'RIGHT', 'DASH']; // 5 Actions

        // --- MOTEUR PHYSIQUE & GRAPHIQUE ---
        const scene = new THREE.Scene();
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -10, 0) });
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.set(0, 50, 40); camera.lookAt(0, 0, 0);

        // Lumière
        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(10, 50, 10); scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Matériaux
        const mat = {
            ground: new CANNON.Material(),
            player: new CANNON.Material(),
            ball: new CANNON.Material()
        };
        // Zéro friction pour les joueurs pour qu'ils glissent bien
        world.addContactMaterial(new CANNON.ContactMaterial(mat.ground, mat.player, { friction: 0.0, restitution: 0 }));
        world.addContactMaterial(new CANNON.ContactMaterial(mat.player, mat.ball, { friction: 0.3, restitution: 0.8 }));
        world.addContactMaterial(new CANNON.ContactMaterial(mat.ground, mat.ball, { friction: 0.3, restitution: 0.7 }));

        // Création Objets
        function createBody(type, col, x, z) {
            const isBall = type === 'ball';
            const geo = isBall ? new THREE.SphereGeometry(1) : new THREE.CylinderGeometry(1.5, 1.5, 1);
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: col }));
            scene.add(mesh);

            const shape = isBall ? new CANNON.Sphere(1) : new CANNON.Cylinder(1.5, 1.5, 1, 8);
            const body = new CANNON.Body({
                mass: isBall ? 1 : 5, // Joueurs lourds
                material: isBall ? mat.ball : mat.player,
                fixedRotation: !isBall,
                linearDamping: isBall ? 0.3 : 0.9 // 0.9 = S'arrête vite si on lâche la touche
            });
            
            // Rotation du cylindre pour CannonJS
            if(!isBall) {
                const q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
                body.addShape(shape, new CANNON.Vec3(0,0,0), q);
            } else {
                body.addShape(shape);
            }

            body.position.set(x, 2, z);
            world.addBody(body);
            return { mesh, body, dashCd: 0 };
        }

        // Terrain
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(50, 80), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        ground.rotation.x = -Math.PI/2; scene.add(ground);
        const groundBody = new CANNON.Body({ mass: 0, material: mat.ground });
        groundBody.addShape(new CANNON.Plane());
        groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
        world.addBody(groundBody);

        // Murs
        function wall(x, z, w, h) {
            const b = new CANNON.Body({ mass: 0 });
            b.addShape(new CANNON.Box(new CANNON.Vec3(w/2, 5, h/2)));
            b.position.set(x, 2, z);
            world.addBody(b);
        }
        wall(26,0,2,80); wall(-26,0,2,80); wall(0,41,50,2); wall(0,-41,50,2);

        // Acteurs
        const ball = createBody('ball', 0xffffff, 0, 0);
        const blue = createBody('player', 0x4488ff, 0, 20);
        const red = createBody('player', 0xff4444, 0, -20);

        // --- IA BRAIN (DQN) ---
        class Agent {
            constructor() {
                this.model = tf.sequential();
                // Entrée: 8 valeurs (Pos Relative X, Z, Vitesse X, Z, Pos Balle Rel X, Z, Dist But)
                this.model.add(tf.layers.dense({inputShape: [8], units: 32, activation: 'relu'}));
                this.model.add(tf.layers.dense({units: 32, activation: 'relu'}));
                this.model.add(tf.layers.dense({units: 5, activation: 'linear'})); // 5 Actions
                this.model.compile({ optimizer: tf.train.adam(CONFIG.learningRate), loss: 'meanSquaredError' });
                
                this.epsilon = 0.2; // 20% Random seulement. 80% Essaye de jouer.
                this.memory = [];
            }

            predict(state) {
                return tf.tidy(() => {
                    if (Math.random() < this.epsilon) return Math.floor(Math.random() * 5);
                    const pred = this.model.predict(tf.tensor2d([state]));
                    return pred.argMax(1).dataSync()[0];
                });
            }

            remember(state, action, reward, nextState) {
                if (this.memory.length > 2000) this.memory.shift();
                this.memory.push({s: state, a: action, r: reward, ns: nextState});
            }

            async train() {
                if (this.memory.length < CONFIG.batchSize) return;
                
                const batch = [];
                // Prendre des souvenirs récents ET aléatoires
                for(let i=0; i<CONFIG.batchSize; i++) {
                    batch.push(this.memory[Math.floor(Math.random() * this.memory.length)]);
                }

                const states = tf.tensor2d(batch.map(e => e.s));
                const nextStates = tf.tensor2d(batch.map(e => e.ns));
                
                const qNow = this.model.predict(states);
                const qNext = this.model.predict(nextStates);
                
                const qNowData = await qNow.array();
                const qNextData = await qNext.dataSync(); // Sync pour vitesse

                const x = []; const y = [];

                for(let i=0; i<CONFIG.batchSize; i++) {
                    const r = batch[i].r;
                    const a = batch[i].a;
                    
                    // Formule Q-Learning : Reward + Futur
                    const target = r + 0.95 * Math.max(qNextData[i*5], qNextData[i*5+1], qNextData[i*5+2]); 
                    
                    qNowData[i][a] = target;
                    
                    x.push(batch[i].s);
                    y.push(qNowData[i]);
                }

                await this.model.fit(tf.tensor2d(x), tf.tensor2d(y), {epochs: 1, verbose: 0});
                
                states.dispose(); nextStates.dispose(); qNow.dispose(); qNext.dispose();
                
                if (this.epsilon > 0.05) this.epsilon *= 0.999;
            }
        }

        const agentBlue = new Agent();
        const agentRed = new Agent();

        // --- GAME LOGIC ---
        function getState(playerBody, targetZ) {
            // Normalisation pour aider le réseau (-1 à 1)
            return [
                playerBody.position.x / 25,
                playerBody.position.z / 40,
                playerBody.velocity.x / 10,
                playerBody.velocity.z / 10,
                (ball.body.position.x - playerBody.position.x) / 50,
                (ball.body.position.z - playerBody.position.z) / 80,
                (targetZ - playerBody.position.z) / 80,
                ball.body.position.distanceTo(playerBody.position) / 50
            ];
        }

        function applyAction(player, actionId) {
            const body = player.body;
            const f = CONFIG.moveForce;
            
            if (player.dashCd > 0) player.dashCd--;

            // Reset couleur
            player.mesh.material.color.setHex(player.mesh.userData.baseColor || player.mesh.material.color.getHex());

            switch(actionId) {
                case 0: body.applyForce(new CANNON.Vec3(0, 0, -f)); break; // UP
                case 1: body.applyForce(new CANNON.Vec3(0, 0, f)); break;  // DOWN
                case 2: body.applyForce(new CANNON.Vec3(-f, 0, 0)); break; // LEFT
                case 3: body.applyForce(new CANNON.Vec3(f, 0, 0)); break;  // RIGHT
                case 4: // DASH
                    if (player.dashCd <= 0) {
                        const dx = ball.body.position.x - body.position.x;
                        const dz = ball.body.position.z - body.position.z;
                        const dist = Math.sqrt(dx*dx + dz*dz) + 0.01;
                        // Dash vers la balle
                        body.applyImpulse(new CANNON.Vec3((dx/dist)*CONFIG.dashForce, 0, (dz/dist)*CONFIG.dashForce));
                        player.dashCd = 60; // 1 sec cooldown
                        
                        // Effet visuel
                        if(!player.mesh.userData.baseColor) player.mesh.userData.baseColor = player.mesh.material.color.getHex();
                        player.mesh.material.color.setHex(0xffffff);
                    }
                    break;
            }
        }

        let sB = 0, sR = 0;
        let lastSB = null, lastSR = null;
        let lastAB = 0, lastAR = 0;

        function update() {
            // Physique rapide
            for(let i=0; i<CONFIG.speed; i++) {
                world.step(1/60);
                
                // --- LOGIQUE IA (toutes les frames pour réactivité) ---
                
                // --- BLEU (Marque en Z = -40) ---
                const stateB = getState(blue.body, -40);
                const actB = agentBlue.predict(stateB);
                applyAction(blue, actB);

                // Apprentissage immédiat
                if (lastSB) {
                    let r = -0.05; // Coût d'existence (pousse à agir vite)
                    const d = ball.body.position.distanceTo(blue.body.position);
                    
                    if (d < 3) r += 0.2; // Proche balle
                    if (d < 1.5) r += 0.5; // Touche balle
                    if (ball.body.velocity.z < -1) r += 0.3; // Balle vers le but
                    
                    agentBlue.remember(lastSB, lastAB, r, stateB);
                }
                lastSB = stateB; lastAB = actB;

                // --- ROUGE (Marque en Z = 40) ---
                const stateR = getState(red.body, 40);
                const actR = agentRed.predict(stateR);
                applyAction(red, actR);

                if (lastSR) {
                    let r = -0.05;
                    const d = ball.body.position.distanceTo(red.body.position);
                    if (d < 3) r += 0.2;
                    if (d < 1.5) r += 0.5;
                    if (ball.body.velocity.z > 1) r += 0.3;
                    
                    agentRed.remember(lastSR, lastAR, r, stateR);
                }
                lastSR = stateR; lastAR = actR;

                // --- BUTS ---
                if (ball.body.position.z < -42) {
                    sB++; reset();
                    agentBlue.remember(lastSB, lastAB, 5, stateB); // Gros reward
                    agentRed.remember(lastSR, lastAR, -2, stateR); // Punition
                }
                if (ball.body.position.z > 42) {
                    sR++; reset();
                    agentRed.remember(lastSR, lastAR, 5, stateR);
                    agentBlue.remember(lastSB, lastAB, -2, stateB);
                }
            }

            // Entraînement léger à chaque frame visuelle
            agentBlue.train();
            agentRed.train();
            
            // Sync Visuel
            blue.mesh.position.copy(blue.body.position);
            red.mesh.position.copy(red.body.position);
            ball.mesh.position.copy(ball.body.position);
            
            // UI
            document.getElementById('sB').innerText = sB;
            document.getElementById('sR').innerText = sR;
            document.getElementById('eps').innerText = Math.floor(agentBlue.epsilon * 100) + "%";
            document.getElementById('mem').innerText = agentBlue.memory.length;

            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        function reset() {
            ball.body.position.set(0, 5, 0); ball.body.velocity.set(0,0,0); ball.body.angularVelocity.set(0,0,0);
            blue.body.position.set(0, 2, 20); blue.body.velocity.set(0,0,0);
            red.body.position.set(0, 2, -20); red.body.velocity.set(0,0,0);
            lastSB = null; lastSR = null;
        }

        update();
    </script>
</body>
</html>
