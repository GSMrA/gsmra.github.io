<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Foot IA - Deep Q-Network & Dash</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #0b0b0b; }
        #overlay {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px;
            width: 350px; user-select: none; border-left: 4px solid #00d2ff;
            font-family: monospace;
        }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 12px; }
        h2 { margin: 0 0 10px 0; font-size: 16px; color: #00d2ff; text-transform: uppercase; letter-spacing: 1px; }
        .bar-bg { width: 100%; background: #333; height: 6px; margin-top: 2px; }
        .bar-fill { height: 100%; transition: width 0.2s; }
        .led { display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #333; margin-right: 5px; }
        .led.on { background: #0f0; box-shadow: 0 0 5px #0f0; }
        #logs { margin-top:10px; height: 80px; overflow-y: auto; color: #666; font-size: 10px; border-top: 1px solid #333; padding-top: 5px;}
    </style>
    <!-- Import Tensorflow et Three -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs"
            }
        }
    </script>
</head>
<body>
    <div id="overlay">
        <h2>DQN Arena <span id="dashLed" class="led"></span></h2>
        <div class="stat-row" style="font-size:16px; font-weight:bold; margin-bottom:10px; justify-content:center;">
            <span style="color:#4488ff">BLEU <span id="scoreB">0</span></span>
            <span style="margin:0 10px">-</span>
            <span style="color:#ff4444">ROUGE <span id="scoreR">0</span></span>
        </div>
        
        <div class="stat-row">
            <span>Exploration (Epsilon)</span>
            <span id="epsVal">100%</span>
        </div>
        <div class="bar-bg"><div id="epsBar" class="bar-fill" style="width:100%; background:#ff9800"></div></div>

        <div class="stat-row" style="margin-top:8px">
            <span>Game Speed</span>
            <span id="speedVal">1x</span>
        </div>
        <input type="range" id="speedSlider" min="1" max="20" value="1" style="width:100%">

        <div id="logs">Initialisation Neural Net...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';
        import * as tf from '@tensorflow/tfjs';

        // --- CONSTANTES ---
        const ACTIONS = {
            STAY: 0, UP: 1, DOWN: 2, LEFT: 3, RIGHT: 4, DASH: 5
        };
        const ACTION_SIZE = 6;
        const STATE_SIZE = 10; // x, z, vx, vz, ballX, ballZ, ballVX, ballVZ, dashCooldown, distToGoal
        
        const HYPER = {
            GAMMA: 0.99,            // Importance du futur (très haute pour stratégie)
            LEARNING_RATE: 0.001,
            BATCH_SIZE: 64,
            MEMORY_SIZE: 50000,
            EPSILON_START: 1.0,
            EPSILON_END: 0.05,
            EPSILON_DECAY: 0.9995
        };

        // --- LOGGER ---
        const logs = document.getElementById('logs');
        function log(msg, color='#888') {
            logs.innerHTML = `<div style="color:${color}">> ${msg}</div>` + logs.innerHTML;
        }

        // --- SCENE & PHYSIQUE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 45, 40);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);

        // Lumière
        const dl = new THREE.DirectionalLight(0xffffff, 2);
        dl.position.set(0, 50, 20);
        dl.castShadow = true;
        dl.shadow.camera.left = -30; dl.shadow.camera.right = 30;
        dl.shadow.camera.top = 30; dl.shadow.camera.bottom = -30;
        scene.add(dl);
        scene.add(new THREE.AmbientLight(0xffffff, 0.2));

        // Physics World
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.81, 0) });
        // Matériaux glissants pour le sol, rebondissants pour la balle
        const matGround = new CANNON.Material();
        const matPlayer = new CANNON.Material();
        const matBall = new CANNON.Material();
        
        world.addContactMaterial(new CANNON.ContactMaterial(matGround, matPlayer, { friction: 0.1, restitution: 0 }));
        world.addContactMaterial(new CANNON.ContactMaterial(matPlayer, matBall, { friction: 0.3, restitution: 0.8 }));
        world.addContactMaterial(new CANNON.ContactMaterial(matGround, matBall, { friction: 0.2, restitution: 0.6 }));

        // --- CREATION OBJETS ---
        const syncs = [];
        
        // Sol
        const ground = new CANNON.Body({ mass: 0, material: matGround, shape: new CANNON.Plane() });
        ground.quaternion.setFromEuler(-Math.PI/2, 0, 0);
        world.addBody(ground);
        const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(50, 80), new THREE.MeshPhongMaterial({color: 0x222222}));
        groundMesh.rotation.x = -Math.PI/2; groundMesh.receiveShadow = true;
        
        // Lignes du terrain
        const grid = new THREE.GridHelper(50, 10, 0x444444, 0x333333);
        grid.scale.z = 1.6;
        scene.add(grid);
        scene.add(groundMesh);

        // Murs invisibles
        function addWall(x,z,w,d) {
            const b = new CANNON.Body({mass:0, shape: new CANNON.Box(new CANNON.Vec3(w/2, 5, d/2))});
            b.position.set(x, 5, z);
            world.addBody(b);
        }
        addWall(26,0,2,80); addWall(-26,0,2,80);
        addWall(0,41,52,2); addWall(0,-41,52,2);

        // Buts
        function addGoal(z, col) {
            const m = new THREE.Mesh(new THREE.BoxGeometry(10, 4, 2), new THREE.MeshBasicMaterial({color:col, wireframe:true}));
            m.position.set(0, 2, z);
            scene.add(m);
        }
        addGoal(-40, 0x0088ff); // But Bleu (à défendre)
        addGoal(40, 0xff4444);  // But Rouge (à défendre)

        function createActor(mass, col, isBall=false) {
            const geo = isBall ? new THREE.SphereGeometry(1) : new THREE.CylinderGeometry(1.5, 1.5, 1, 16);
            const mat = new THREE.MeshStandardMaterial({color: col});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true; scene.add(mesh);
            
            const shape = isBall ? new CANNON.Sphere(1) : new CANNON.Cylinder(1.5, 1.5, 1, 16);
            const body = new CANNON.Body({ mass: mass, material: isBall ? matBall : matPlayer, fixedRotation: !isBall });
            if(!isBall) {
                // Quaternion pour le cylindre vertical
                const q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
                body.addShape(shape, new CANNON.Vec3(0,0,0), q);
                body.linearDamping = 0.9; // Friction de l'air pour arrêter le joueur
            } else {
                body.addShape(shape);
                body.linearDamping = 0.4;
            }
            world.addBody(body);
            syncs.push({mesh, body});
            return {mesh, body};
        }

        const ball = createActor(1, 0xffffff, true);
        const blue = createActor(5, 0x0088ff);
        const red = createActor(5, 0xff4444);

        // --- DASH EFFECT ---
        function triggerDashEffect(mesh) {
            const originalColor = mesh.material.color.getHex();
            mesh.material.color.setHex(0xffffff);
            mesh.scale.set(1.4, 1.4, 1.4);
            setTimeout(() => {
                mesh.material.color.setHex(originalColor);
                mesh.scale.set(1,1,1);
            }, 100);
        }

        // --- DQN BRAIN ---
        class DQNAgent {
            constructor(colorId) { // 1 = Blue (Goal at 40), -1 = Red (Goal at -40)
                this.model = this.createModel();
                this.targetModel = this.createModel(); // Pour la stabilité
                this.memory = [];
                this.epsilon = HYPER.EPSILON_START;
                this.colorId = colorId; 
                this.dashCooldown = 0;
                this.updateTarget();
            }

            createModel() {
                const model = tf.sequential();
                model.add(tf.layers.dense({inputShape: [STATE_SIZE], units: 64, activation: 'relu'}));
                model.add(tf.layers.dense({units: 64, activation: 'relu'}));
                model.add(tf.layers.dense({units: ACTION_SIZE, activation: 'linear'})); // Q-values
                model.compile({optimizer: tf.train.adam(HYPER.LEARNING_RATE), loss: 'meanSquaredError'});
                return model;
            }

            updateTarget() {
                this.targetModel.setWeights(this.model.getWeights());
            }

            act(state) {
                // Epsilon Greedy
                if (Math.random() < this.epsilon) {
                    return Math.floor(Math.random() * ACTION_SIZE);
                }
                return tf.tidy(() => {
                    const pred = this.model.predict(tf.tensor2d([state]));
                    return pred.argMax(1).dataSync()[0];
                });
            }

            remember(state, action, reward, nextState, done) {
                if(this.memory.length >= HYPER.MEMORY_SIZE) this.memory.shift();
                this.memory.push({s:state, a:action, r:reward, ns:nextState, d:done});
            }

            async replay() {
                if(this.memory.length < HYPER.BATCH_SIZE) return;

                const batch = [];
                // Random sample
                for(let i=0; i<HYPER.BATCH_SIZE; i++) {
                    batch.push(this.memory[Math.floor(Math.random()*this.memory.length)]);
                }

                const states = batch.map(e => e.s);
                const nextStates = batch.map(e => e.ns);
                
                const tfStates = tf.tensor2d(states);
                const tfNextStates = tf.tensor2d(nextStates);

                const qCurrent = this.model.predict(tfStates);
                const qNext = this.targetModel.predict(tfNextStates); // Utilise Target Network
                
                const qCurrentData = await qCurrent.array();
                const qNextData = await qNext.array();

                const x = [];
                const y = [];

                for(let i=0; i<HYPER.BATCH_SIZE; i++) {
                    const {s, a, r, d} = batch[i];
                    const currentQ = qCurrentData[i];
                    
                    // Bellman Equation: Q(s,a) = r + gamma * max(Q(s', a'))
                    let target = r;
                    if(!d) {
                        target = r + HYPER.GAMMA * Math.max(...qNextData[i]);
                    }

                    currentQ[a] = target; // On update seulement l'action choisie
                    x.push(s);
                    y.push(currentQ);
                }

                await this.model.fit(tf.tensor2d(x), tf.tensor2d(y), {epochs:1, verbose:0});
                
                tfStates.dispose(); tfNextStates.dispose(); qCurrent.dispose(); qNext.dispose();

                // Decay Epsilon
                if(this.epsilon > HYPER.EPSILON_END) this.epsilon *= HYPER.EPSILON_DECAY;
            }
        }

        const agentBlue = new DQNAgent(1); // Score en Z > 0
        const agentRed = new DQNAgent(-1); // Score en Z < 0

        // --- GAME LOGIC ---
        let scoreB = 0, scoreR = 0;
        let simSpeed = 1;

        // Normalise les données pour le réseau
        function getState(body, targetZ) {
            return [
                body.position.x / 25, 
                body.position.z / 40,
                body.velocity.x / 20,
                body.velocity.z / 20,
                (ball.body.position.x - body.position.x) / 50, // Delta X Ball
                (ball.body.position.z - body.position.z) / 80, // Delta Z Ball
                ball.body.velocity.x / 20,
                ball.body.velocity.z / 20,
                (targetZ - body.position.z) / 80, // Dist goal Z
                (targetZ - ball.body.position.z) / 80 // Dist ball to goal
            ];
        }

        function resetPositions() {
            ball.body.position.set(0, 5, 0); ball.body.velocity.set(0,0,0); ball.body.angularVelocity.set(0,0,0);
            blue.body.position.set(0, 2, 25); blue.body.velocity.set(0,0,0);
            red.body.position.set(0, 2, -25); red.body.velocity.set(0,0,0);
        }

        function executeAction(agent, body, mesh, action) {
            const speed = 40;
            const dashSpeed = 250;
            let force = new CANNON.Vec3(0,0,0);

            if(agent.dashCooldown > 0) agent.dashCooldown--;

            switch(action) {
                case ACTIONS.UP: force.z = -speed; break;
                case ACTIONS.DOWN: force.z = speed; break;
                case ACTIONS.LEFT: force.x = -speed; break;
                case ACTIONS.RIGHT: force.x = speed; break;
                case ACTIONS.DASH:
                    if(agent.dashCooldown <= 0) {
                        // Dash vers la balle
                        const dx = ball.body.position.x - body.position.x;
                        const dz = ball.body.position.z - body.position.z;
                        const dist = Math.sqrt(dx*dx+dz*dz);
                        force.set((dx/dist)*dashSpeed, 0, (dz/dist)*dashSpeed);
                        triggerDashEffect(mesh);
                        agent.dashCooldown = 60; // 1 sec cooldown @ 60fps
                        document.getElementById('dashLed').classList.add('on');
                        setTimeout(() => document.getElementById('dashLed').classList.remove('on'), 100);
                    }
                    break;
            }
            body.applyForce(force);
        }

        // --- MAIN LOOP ---
        let frame = 0;
        let lastStateB = null, lastActionB = null;
        let lastStateR = null, lastActionR = null;

        function update() {
            for(let s=0; s<simSpeed; s++) {
                world.step(1/60);
                frame++;

                if (frame % 300 === 0) { // Update target networks toutes les 5 sec
                    agentBlue.updateTarget();
                    agentRed.updateTarget();
                }

                // AI DECISION (toutes les 4 frames pour stabilité)
                if(frame % 4 === 0) {
                    // --- BLEU (Attaque vers Z = -40) ---
                    const sB = getState(blue.body, -40);
                    // Calcul Reward précédent
                    if(lastStateB) {
                        let r = -0.01; // Penalty de temps
                        const dBall = blue.body.position.distanceTo(ball.body.position);
                        
                        // Shaping Reward (Indispensable pour qu'ils ne soient pas cons)
                        if (dBall < 2.5) r += 0.1; // Proche balle
                        
                        // Si la balle va vers le but adverse (bon vecteur)
                        if (ball.body.velocity.z < -2) r += 0.2; 
                        
                        agentBlue.remember(lastStateB, lastActionB, r, sB, false);
                    }
                    const aB = agentBlue.act(sB);
                    executeAction(agentBlue, blue.body, blue.mesh, aB);
                    lastStateB = sB; lastActionB = aB;

                    // --- ROUGE (Attaque vers Z = 40) ---
                    const sR = getState(red.body, 40);
                    if(lastStateR) {
                        let r = -0.01;
                        const dBall = red.body.position.distanceTo(ball.body.position);
                        if (dBall < 2.5) r += 0.1; 
                        if (ball.body.velocity.z > 2) r += 0.2; 
                        
                        agentRed.remember(lastStateR, lastActionR, r, sR, false);
                    }
                    const aR = agentRed.act(sR);
                    executeAction(agentRed, red.body, red.mesh, aR);
                    lastStateR = sR; lastActionR = aR;
                }

                // --- BUTS ---
                if(ball.body.position.z < -42) { // BUT BLEU
                    scoreB++;
                    document.getElementById('scoreB').innerText = scoreB;
                    log("BUT BLEU !!!", "#4488ff");
                    // Huge reward
                    agentBlue.remember(lastStateB, lastActionB, 10, lastStateB, true);
                    agentRed.remember(lastStateR, lastActionR, -5, lastStateR, true); // Penalty goal encaissé
                    agentBlue.replay(); agentRed.replay();
                    resetPositions();
                    lastStateB = null; lastStateR = null;
                }
                else if(ball.body.position.z > 42) { // BUT ROUGE
                    scoreR++;
                    document.getElementById('scoreR').innerText = scoreR;
                    log("BUT ROUGE !!!", "#ff4444");
                    agentRed.remember(lastStateR, lastActionR, 10, lastStateR, true);
                    agentBlue.remember(lastStateB, lastActionB, -5, lastStateB, true);
                    agentBlue.replay(); agentRed.replay();
                    resetPositions();
                    lastStateB = null; lastStateR = null;
                }

                // Train continu (mini batch)
                if(frame % 10 === 0) {
                    agentBlue.replay();
                    agentRed.replay();
                }
            }
        }

        // --- ANIMATION ---
        document.getElementById('speedSlider').addEventListener('input', e => {
            simSpeed = parseInt(e.target.value);
            document.getElementById('speedVal').innerText = simSpeed + "x";
        });

        function animate() {
            requestAnimationFrame(animate);
            update();
            
            // Sync Visuel
            syncs.forEach(o => {
                o.mesh.position.copy(o.body.position);
                o.mesh.quaternion.copy(o.body.quaternion);
            });

            // UI
            const epsPct = Math.floor(agentBlue.epsilon * 100);
            document.getElementById('epsVal').innerText = epsPct + "%";
            document.getElementById('epsBar').style.width = epsPct + "%";

            controls.update();
            renderer.render(scene, camera);
        }

        log("Moteur Physique prêt.");
        log("Démarrage Deep Q-Learning...");
        resetPositions();
        animate();

    </script>
</body>
</html>
