<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Foot IA - Caméra Libre & Buts 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: monospace; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.85); color: white;
            padding: 15px; border-radius: 8px; width: 280px;
            pointer-events: none; /* Laisse passer la souris pour la caméra */
            user-select: none;
            border-left: 5px solid #00ff88;
        }
        .row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .score { font-size: 24px; font-weight: bold; text-align: center; margin: 10px 0; }
        .b { color: #4488ff; } .r { color: #ff4444; }
        #logs { font-size: 10px; color: #888; height: 60px; overflow: hidden; margin-top:10px; border-top:1px solid #333; padding-top:5px;}
    </style>
    
    <!-- Import des librairies -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs"
            }
        }
    </script>
</head>
<body>
    <div id="ui">
        <div class="row"><span>IA STATUS:</span> <span style="color:#0f0">EN LIGNE</span></div>
        <div class="score"><span class="b" id="sB">0</span> - <span class="r" id="sR">0</span></div>
        <div class="row"><span>Exploration:</span> <span id="eps">20%</span></div>
        <div class="row"><span>Mémoire:</span> <span id="mem">0</span></div>
        <div id="logs">Initialisation du stade...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';
        import * as tf from '@tensorflow/tfjs';

        // --- 1. CONFIGURATION ---
        const CONFIG = {
            speed: 2,           // Vitesse simulation physique
            moveForce: 80,      // Puissance moteur
            dashForce: 450,     // Puissance Dash
            batchSize: 32,
            learningRate: 0.005 
        };

        // --- 2. SCÈNE & CAMÉRA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(60, 50, 0); // Vue de côté élevée
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // CONTROLES CAMÉRA (Activés !)
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lumière
        const dl = new THREE.DirectionalLight(0xffffff, 1.5);
        dl.position.set(20, 50, 20);
        dl.castShadow = true;
        scene.add(dl);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- 3. PHYSIQUE ---
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -10, 0) });
        
        // Matériaux (Glissant pour le sol, Rebondissant pour la balle)
        const matGround = new CANNON.Material();
        const matPlayer = new CANNON.Material();
        const matBall = new CANNON.Material();

        world.addContactMaterial(new CANNON.ContactMaterial(matGround, matPlayer, { friction: 0.0, restitution: 0 }));
        world.addContactMaterial(new CANNON.ContactMaterial(matPlayer, matBall, { friction: 0.3, restitution: 0.8 }));
        world.addContactMaterial(new CANNON.ContactMaterial(matGround, matBall, { friction: 0.3, restitution: 0.6 }));

        // --- 4. CRÉATION DU MONDE ---
        
        // Sol
        const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 90), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        groundMesh.rotation.x = -Math.PI/2; 
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
        
        const groundBody = new CANNON.Body({ mass: 0, material: matGround });
        groundBody.addShape(new CANNON.Plane());
        groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
        world.addBody(groundBody);

        // Murs invisibles
        function addWall(x, z, w, d) {
            const b = new CANNON.Body({ mass: 0 });
            b.addShape(new CANNON.Box(new CANNON.Vec3(w/2, 5, d/2)));
            b.position.set(x, 2, z);
            world.addBody(b);
        }
        addWall(28, 0, 2, 90); addWall(-28, 0, 2, 90);
        addWall(0, 44, 60, 2); addWall(0, -44, 60, 2);

        // BUTS (Cages visibles)
        function createGoal(z, color, isRedGoal) {
            const goalGroup = new THREE.Group();
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            // Poteaux
            const p1 = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 1), mat); p1.position.set(5, 2, 0);
            const p2 = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 1), mat); p2.position.set(-5, 2, 0);
            const crossbar = new THREE.Mesh(new THREE.BoxGeometry(11, 1, 1), mat); crossbar.position.set(0, 4.5, 0);
            
            goalGroup.add(p1, p2, crossbar);
            goalGroup.position.set(0, 0, z);
            scene.add(goalGroup);

            // Trigger physique (au fond des cages)
            // On ne met pas de corps physique pour les poteaux pour simplifier, juste un mur au fond
        }
        createGoal(-40, 0x0088ff); // But Bleu (Zone de défense bleue)
        createGoal(40, 0xff4444);  // But Rouge (Zone de défense rouge)

        // Joueurs & Balle
        function createActor(type, color, x, z) {
            const isBall = type === 'ball';
            const geo = isBall ? new THREE.SphereGeometry(1) : new THREE.CylinderGeometry(1.5, 1.5, 1, 16);
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: color }));
            mesh.castShadow = true; scene.add(mesh);

            const shape = isBall ? new CANNON.Sphere(1) : new CANNON.Cylinder(1.5, 1.5, 1, 16);
            const body = new CANNON.Body({
                mass: isBall ? 1 : 5,
                material: isBall ? matBall : matPlayer,
                fixedRotation: !isBall,
                linearDamping: isBall ? 0.3 : 0.9 // Friction de l'air
            });

            if(!isBall) {
                const q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
                body.addShape(shape, new CANNON.Vec3(0,0,0), q);
            } else {
                body.addShape(shape);
            }
            
            body.position.set(x, 2, z);
            world.addBody(body);
            return { mesh, body, dashCd: 0 };
        }

        const ball = createActor('ball', 0xffffff, 0, 0);
        const blue = createActor('player', 0x4488ff, 0, 20);
        const red = createActor('player', 0xff4444, 0, -20);

        // --- 5. INTELLIGENCE ARTIFICIELLE (DQN) ---
        class Agent {
            constructor() {
                this.model = tf.sequential();
                // 8 inputs -> 32 -> 32 -> 5 outputs (Actions)
                this.model.add(tf.layers.dense({inputShape: [8], units: 32, activation: 'relu'}));
                this.model.add(tf.layers.dense({units: 32, activation: 'relu'}));
                this.model.add(tf.layers.dense({units: 5, activation: 'linear'}));
                this.model.compile({ optimizer: tf.train.adam(CONFIG.learningRate), loss: 'meanSquaredError' });
                
                this.epsilon = 0.2; // 20% Random seulement
                this.memory = [];
            }

            predict(state) {
                return tf.tidy(() => {
                    if (Math.random() < this.epsilon) return Math.floor(Math.random() * 5);
                    const pred = this.model.predict(tf.tensor2d([state]));
                    return pred.argMax(1).dataSync()[0];
                });
            }

            remember(s, a, r, ns) {
                if(this.memory.length > 2000) this.memory.shift();
                this.memory.push({s, a, r, ns});
            }

            async train() {
                if(this.memory.length < CONFIG.batchSize) return;
                
                const batch = [];
                for(let i=0; i<CONFIG.batchSize; i++) {
                    batch.push(this.memory[Math.floor(Math.random() * this.memory.length)]);
                }

                const states = tf.tensor2d(batch.map(e => e.s));
                const nextStates = tf.tensor2d(batch.map(e => e.ns));
                const qNext = this.model.predict(nextStates);
                const qNextData = await qNext.dataSync();

                const x = [];
                const y = await this.model.predict(states).array(); // Get current Q-values

                for(let i=0; i<CONFIG.batchSize; i++) {
                    const {s, a, r} = batch[i];
                    // Q-Learning Formula: Q(s,a) = r + gamma * max(Q(s'))
                    y[i][a] = r + 0.95 * Math.max(qNextData[i*5], qNextData[i*5+1], qNextData[i*5+2], qNextData[i*5+3], qNextData[i*5+4]);
                    x.push(s);
                }

                await this.model.fit(tf.tensor2d(x), tf.tensor2d(y), {epochs: 1, verbose: 0});
                
                states.dispose(); nextStates.dispose(); qNext.dispose();
                
                if(this.epsilon > 0.05) this.epsilon *= 0.999;
            }
        }

        const agentBlue = new Agent();
        const agentRed = new Agent();

        // --- 6. GAMEPLAY ---
        
        function getState(playerBody, targetZ) {
            // Normalisation des entrées pour le réseau (-1 à 1 environ)
            return [
                playerBody.position.x / 30,
                playerBody.position.z / 45,
                playerBody.velocity.x / 15,
                playerBody.velocity.z / 15,
                (ball.body.position.x - playerBody.position.x) / 60,
                (ball.body.position.z - playerBody.position.z) / 90,
                (targetZ - playerBody.position.z) / 90,
                ball.body.position.distanceTo(playerBody.position) / 50
            ];
        }

        function applyAction(player, action) {
            const body = player.body;
            const F = CONFIG.moveForce;
            
            if(player.dashCd > 0) player.dashCd--;
            
            // Reset couleur (sauf si dash)
            if(player.dashCd === 0) player.mesh.material.color.setHex(player.mesh.userData.baseCol || player.mesh.material.color.getHex());

            switch(action) {
                case 0: body.applyForce(new CANNON.Vec3(0, 0, -F)); break; // UP
                case 1: body.applyForce(new CANNON.Vec3(0, 0, F)); break;  // DOWN
                case 2: body.applyForce(new CANNON.Vec3(-F, 0, 0)); break; // LEFT
                case 3: body.applyForce(new CANNON.Vec3(F, 0, 0)); break;  // RIGHT
                case 4: // DASH
                    if(player.dashCd <= 0) {
                        const dx = ball.body.position.x - body.position.x;
                        const dz = ball.body.position.z - body.position.z;
                        const dist = Math.sqrt(dx*dx + dz*dz) + 0.01;
                        body.applyImpulse(new CANNON.Vec3((dx/dist)*CONFIG.dashForce, 0, (dz/dist)*CONFIG.dashForce));
                        
                        player.dashCd = 60; // Cooldown 1 seconde
                        
                        if(!player.mesh.userData.baseCol) player.mesh.userData.baseCol = player.mesh.material.color.getHex();
                        player.mesh.material.color.setHex(0xffffff); // Flash blanc
                    }
                    break;
            }
        }

        // États précédents pour le Learning
        let lastStateB, lastActionB, lastStateR, lastActionR;
        let scoreB = 0, scoreR = 0;

        function update() {
            // Boucle physique rapide
            for(let i=0; i<CONFIG.speed; i++) {
                world.step(1/60);

                // --- IA BLEU (Attaque Z = -40, là où est le but bleu sur l'écran mais c'est le but adverse) ---
                // Correction logique : Bleu commence en +20, Attaque le but Rouge en -40.
                const sB = getState(blue.body, -40);
                const aB = agentBlue.predict(sB);
                applyAction(blue, aB);

                if(lastStateB) {
                    // Reward Shaping : Guide l'IA
                    let r = -0.01; // Pénalité de temps
                    const d = blue.body.position.distanceTo(ball.body.position);
                    
                    if(d < 2.5) r += 0.1; // S'approche
                    if(d < 1.5) r += 0.5; // Touche
                    if(ball.body.velocity.z < -1) r += 0.2; // Pousse vers but adverse (-Z)
                    
                    agentBlue.remember(lastStateB, lastActionB, r, sB);
                }
                lastStateB = sB; lastActionB = aB;

                // --- IA ROUGE (Attaque Z = 40) ---
                const sR = getState(red.body, 40);
                const aR = agentRed.predict(sR);
                applyAction(red, aR);

                if(lastStateR) {
                    let r = -0.01;
                    const d = red.body.position.distanceTo(ball.body.position);
                    
                    if(d < 2.5) r += 0.1;
                    if(d < 1.5) r += 0.5;
                    if(ball.body.velocity.z > 1) r += 0.2; // Pousse vers but adverse (+Z)
                    
                    agentRed.remember(lastStateR, lastActionR, r, sR);
                }
                lastStateR = sR; lastActionR = aR;

                // --- BUTS ---
                if(ball.body.position.z < -42) { // Dans but du fond (But pour Bleu)
                    scoreB++; resetPositions();
                    agentBlue.remember(lastStateB, lastActionB, 5, sB);
                    agentRed.remember(lastStateR, lastActionR, -2, sR);
                }
                if(ball.body.position.z > 42) { // Dans but de devant (But pour Rouge)
                    scoreR++; resetPositions();
                    agentRed.remember(lastStateR, lastActionR, 5, sR);
                    agentBlue.remember(lastStateB, lastActionB, -2, sB);
                }
            }

            // Entraînement léger à chaque frame
            agentBlue.train();
            agentRed.train();

            // Rendu
            blue.mesh.position.copy(blue.body.position);
            red.mesh.position.copy(red.body.position);
            ball.mesh.position.copy(ball.body.position);
            
            // UI
            document.getElementById('sB').innerText = scoreB;
            document.getElementById('sR').innerText = scoreR;
            document.getElementById('eps').innerText = Math.floor(agentBlue.epsilon * 100) + "%";
            document.getElementById('mem').innerText = agentBlue.memory.length;

            controls.update(); // Important pour la caméra !
            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        function resetPositions() {
            ball.body.position.set(0, 5, 0); ball.body.velocity.set(0,0,0); ball.body.angularVelocity.set(0,0,0);
            blue.body.position.set(0, 2, 20); blue.body.velocity.set(0,0,0);
            red.body.position.set(0, 2, -20); red.body.velocity.set(0,0,0);
            lastStateB = null; lastStateR = null;
        }

        update();
    </script>
</body>
</html>
